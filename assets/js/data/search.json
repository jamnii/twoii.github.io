[
  
  {
    "title": "MySQL Transaction",
    "url": "/posts/mysql-transaction/",
    "categories": "MySQL",
    "tags": "transaction",
    "date": "2021-02-20 16:42:00 +0800",
    





    "snippet": "MySQL 事务主要用于处理操作量大，复杂度高的数据。1. 基础介绍2. ACIDAtomicity原子性: 一个事务被视为一个不可分割的最小工作单元 一个事务中的所有操作，要么全部完成，要么全部不完成，不会在中间某个环节结束。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态Consistency一致性: 在事务开始之前和事务结束以后，数据库数据的一致性约束没有被破坏。 保证在一个事务中的多次操作的数据中间状态,对其他事务不可见的。因为这些中间状态，是一个过渡状态，与事务的开始状态和事务的结束状态是不一致的，一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见。(memberA 向 memberB 转 100,在其它事物看来,要么 memberA 减少了, 要么 memberB 增加了)不会看到 memberA 减少了, memberB还没有加的情况,这个属于中间状态)与 `Atomicity` 的区别: 未提交读的隔离级别下是事务内部操作是可见的，明显违背了一致性。Isolation隔离性: 数据库允许多个并发事务同时对数据进行读写和修改的能力。 隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。Durability持久性: 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。3. 隔离级别针对多个事物的数据处理，不同的隔离级别对数据会有不同的影响。      设置事物隔离级别    show variables like &quot;%isolation%&quot;;&quot;read uncommitted, read committed, repeatable read, serializable&quot;set session transaction isolation level repeatable read;            锁测试    关闭自动提交#show variables like &quot;autocommit&quot;;set session autocommit=0;#开始事物start transaction;#sqlcommit;#查看事务与锁信息show engine innodb status;#分析sql,死锁:1.没走行锁,索引失效,全表扫描explain sql;            autocommit              自动提交: 如果 autocommit 开启，则每个SQL语句将自己形成一个事务。                  非自动提交: 需要执行多语句事务 START TRANSACTION 或 BEGIN 语句，并用它结束 COMMIT或 ROLLBACK 声明。      Read-Uncommitted读-未提交，有脏读数据: name = test， A事物更新 name = test2，同时B事物开启，B执行查询name = test2，若A回滚，实际数据为 name = test，而B却返回了 name = test2，这就称之为脏读.Read(B事物读取)-Uncommitted(A事物未提交成功的操作[更新]数据): 有脏读。TimeLine                   原数据 name = testA事物 ↓start ↓执行更新 ↓name = test2    此时     B事物 → start → 查询 -&amp;gt; name = test2 ↓                                                  ↓回滚                                          返回(name = test2)A事物并没有修改成功，但B事物已经返回 name = test2，出现了脏读Read-Committed读-已提交,不可重复读一个事务只能读到另一个事务修改的已经提交了事务的数据。A隐式提交了事物，B查询 name = test2，这是没有问题的。但B还没有结束，A中执行更新 name = test3，B执行查询 name = test3，这种称之为 不可重复读。Read(B事物读取)-Committed(A事物提交成功的操作[更新]数据): 不可重复读，Commit 后数据发生改变。TimeLine                原数据 name = testB事物                    A事物 ↓                        ↓start                   start → 执行 name = test2 → commit.(At1) ↓查询(name = test2) ↓其它操作                 A事物 ↓                       ↓其它操作                 start → 执行 name = test3 → commit.(At2) ↓查询(name = test3) ↓提交在B事物的时间线中，A事物对数据进行了两次操作，B事物进行了两次查询，但只能读取到操作后的数据。数据会跟着事物修改而改变。Tips:1.在RC隔离级别下并不是不会出现死锁，只是出现几率比RR低而已！2.在RC隔离级别下，条件列未命中索引只会锁行！3.在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性！减少了更新同一行记录时的冲突，减少锁等待。4.半一致性读: 所谓半一致性读就是，一个update语句，如果读到一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，由MySQL上层判断此版本是否满足update的where条件。若满足(需要更新)，则MySQL会重新发起一次读操作，此时会读取行的最新版本(并加锁)！Repeatable-Read可重复读第一次读取的数据，即使别的事务修改的这个值，这个事务再读取这条数据的时候还是和第一次获取的一样，不会随着别的事务的修改而改变。原始数据 name = test， 开启A、B两个事物， A修改 name = test2，同时B事物查询 name = test,不管事物A是否提交，在B事物没有提交之前，这条数据对B来说一直都是没有发生改变的，是可以重复的被读到。TimeLine                原数据 name = testB事物                    A事物 ↓                        ↓start                   start ↓                        ↓查询(name = test)       修改(name = test2)  → 提交 ↓再次查询(name = test) ↓查询(name = test) ↓提交在B事物的时间线中，不管A事物执行什么操作，或者执行回滚或提交。B事物的值始终为第一次获取的值。数据不会跟着事物修改而改变。Tips:1.在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多！2.在RR隔离级别下，条件列未命中索引会锁表！Serializable串行化只能进行读-读并发。只要有一个事务操作一条记录的写，那么其他要访问这条记录的事务都得等着一般没人用串行化，性能比较低，常用的是已提交读和可重复读。"
  },
  
  {
    "title": "Getting Started",
    "url": "/posts/getting-start/",
    "categories": "Blogging, Tutorial",
    "tags": "getting started",
    "date": "2019-08-09 20:55:00 +0800",
    





    "snippet": "PrerequisitesFollow the instructions in the Jekyll Docs to complete the installation of Ruby, RubyGems, Jekyll, and Bundler.InstallationCreating a New SiteThere are two ways to create a new repository for this theme:  Using the Chirpy Starter - Easy to upgrade, isolates irrelevant project files so you can focus on writing.  Forking on GitHub - Convenient for custom development, but difficult to upgrade. Unless you are familiar with Jekyll and are determined to tweak or contribute to this project, this approach is not recommended.Option 1. Using the Chirpy StarterCreate a new repository from the Chirpy Starter and name it &amp;lt;GH_USERNAME&amp;gt;.github.io, where GH_USERNAME represents your GitHub username.Option 2. Forking on GitHubFork Chirpy on GitHub and rename it to &amp;lt;GH_USERNAME&amp;gt;.github.io. Please note that the default branch code is in development.  If you want the site to be stable, please switch to the latest tag and start writing.And then execute:$ bash tools/init.sh  Note: If you don’t want to deploy your site on GitHub Pages, append option --no-gh at the end of the above command.The above command will:  Removes some files or directories from your repository:          .travis.yml      files under _posts      folder docs            If the option --no-gh is provided, the directory .github will be deleted. Otherwise, set up the GitHub Action workflow by removing the extension .hook of .github/workflows/pages-deploy.yml.hook, and then remove the other files and directories in the folder .github.        Removes item Gemfile.lock from .gitignore.    Creates a new commit to save the changes automatically.Installing DependenciesBefore running for the first time, go to the root directory of your site, and install dependencies as follows:$ bundleUsageConfigurationUpdate the variables of _config.yml as needed. Some of them are typical options:  url  avatar  timezone  langCustoming StylesheetIf you need to customize the stylesheet, copy the theme’s assets/css/style.scss to the same path on your Jekyll site, and then add the custom style at the end of the style file.Starting from v4.1.0, if you want to overwrite the SASS variables defined in _sass/addon/variables.scss, create a new file _sass/variables-hook.scss and assign new values to the target variable in it.Running Local ServerYou may want to preview the site contents before publishing, so just run it by:$ bundle exec jekyll sOr run the site on Docker with the following command:$ docker run -it --rm \\    --volume=&quot;$PWD:/srv/jekyll&quot; \\    -p 4000:4000 jekyll/jekyll \\    jekyll serveAfter a while, the local service will be published at http://127.0.0.1:4000.DeploymentBefore the deployment begins, check out the file _config.yml and make sure the url is configured correctly. Furthermore, if you prefer the project site and don’t use a custom domain, or you want to visit your website with a base URL on a web server other than GitHub Pages, remember to change the baseurl to your project name that starts with a slash, e.g, /project-name.Now you can choose ONE of the following methods to deploy your Jekyll site.Deploy by Using Github ActionsFor security reasons, GitHub Pages build runs on safe mode, which restricts us from using plugins to generate additional page files. Therefore, we can use GitHub Actions to build the site, store the built site files on a new branch, and use that branch as the source of the GitHub Pages service.Quickly check the files needed for GitHub Actions build:      Ensure your Jekyll site has the file .github/workflows/pages-deploy.yml. Otherwise, create a new one and fill in the contents of the sample file, and the value of the on.push.branches should be the same as your repo’s default branch name.        Ensure your Jekyll site has file tools/deploy.sh. Otherwise, copy it from here to your Jekyll site.        Furthermore, if you have committed Gemfile.lock to the repo, and your runtime system is not Linux, don’t forget to update the platform list in the lock file:    $ bundle lock --add-platform x86_64-linux      After the above steps, rename your repository to &amp;lt;GH_USERNAME&amp;gt;.github.io on GitHub.Now publish your Jekyll site by:      Push any commit to remote to trigger the GitHub Actions workflow. Once the build is complete and successful, a new remote branch named gh-pages will appear to store the built site files.        Browse to your repository on GitHub. Select the tab Settings, then click Pages in the left navigation bar, and then in the section Source of GitHub Pages, select the /(root) directory of branch gh-pages as the publishing source. Remember to click Save before leaving.            Visit your website at the address indicated by GitHub.  Manually Build and DeployOn self-hosted servers, you cannot enjoy the convenience of GitHub Actions. Therefore, you should build the site on your local machine and then upload the site files to the server.Go to the root of the source project, and build your site as follows:$ JEKYLL_ENV=production bundle exec jekyll bOr build the site on Docker:$ docker run -it --rm \\    --env JEKYLL_ENV=production \\    --volume=&quot;$PWD:/srv/jekyll&quot; \\    jekyll/jekyll \\    jekyll buildUnless you specified the output path, the generated site files will be placed in folder _site of the project’s root directory. Now you should upload those files to the target server.UpgradingIt depends on how you use the theme:      If you are using the theme gem (there will be gem &quot;jekyll-theme-chirpy&quot; in the Gemfile), editing the Gemfile and update the version number of the theme gem, for example:    - gem &quot;jekyll-theme-chirpy&quot;, &quot;~&amp;gt; 3.2&quot;, &quot;&amp;gt;= 3.2.1&quot;+ gem &quot;jekyll-theme-chirpy&quot;, &quot;~&amp;gt; 3.3&quot;, &quot;&amp;gt;= 3.3.0&quot;        And then execute the following command:    $ bundle update jekyll-theme-chirpy        As the version upgrades, the critical files (for details, see the Startup Template) and configuration options will change. Please refer to the Upgrade Guide to keep your repo’s files in sync with the latest version of the theme.        If you forked from the source project (there will be gemspec in the Gemfile of your site), then merge the latest upstream tags into your Jekyll site to complete the upgrade.The merge is likely to conflict with your local modifications. Please be patient and careful to resolve these conflicts.  "
  },
  
  {
    "title": "高内聚低耦合",
    "url": "/posts/hight-low-design/",
    "categories": "Design",
    "tags": "",
    "date": "2017-03-15 00:00:00 +0800",
    





    "snippet": "模块之间存在依赖， 导致改动可能会互相影响， 关系越紧密， 耦合越强， 模块独立性越差。模块内部的元素，关联性越强， 则内聚越高， 模块单一性更强。模块模块就是从逻辑上将系统分解为更细微的部分， 分而治之， 复杂问题拆解为若干简单问题， 逐个解决。耦合主要描述模块之间的关系， 内聚主要描述模块内部。 模块的粒度可大可小， 可以是函数， 类， 功能块等等。耦合模块之间存在依赖， 导致改动可能会互相影响， 关系越紧密， 耦合越强， 模块独立性越差。比如模块A直接操作了模块B中数据， 则视为强耦合， 若A只是通过数据与模块B交互， 则视为弱耦合。独立的模块便于扩展， 维护， 写单元测试， 如果模块之间重重依赖， 会极大降低开发效率。内聚模块内部的元素， 关联性越强， 则内聚越高， 模块单一性更强。 一个模块应当尽可能独立完成某个功能，如果有各种场景需要被引入到当前模块， 代码质量将变得非常脆弱， 这种情况建议拆分为多个模块。低内聚的模块代码， 不管是维护， 扩展还是重构都相当麻烦， 难以下手。接口设计原则好的接口应当满足设计模式六大原则， 很多设计模式， 框架都是基于高内聚低耦合这个出发点的。  单一职责原则：一个类只负责一个功能领域中的相应职责。  开闭原则：一个软件实体应当对扩展开放，对修改关闭。  里氏代换原则：所有引用基类（父类）的地方必须能透明地使用其子类的对象。  依赖倒转原则：抽象不应该依赖于细节， 细节应当依赖于抽象。 换言之， 要针对接口编程， 而不是针对实现编程。  接口隔离原则：使用多个专门的接口， 而不使用单一的总接口， 即客户端不应该依赖那些它不需要的接口。  迪米特法则： 一个软件实体应当尽可能少地与其他实体发生相互作用， 例如外观模式， 对外暴露统一接口。举几个栗子外观模式为系统中多个子系统提供一致的对外调用， 对客户端隐藏子系统细节， 降低其与子系统的耦合。桥接模式JDBC中的把面向厂商的接口(Driver)和面向使用者的API(DriverManager)做了拆分隔离。适配器模式引入第三方库(hibernate， log4j)， 不应该直接在代码中继承或者使用其实体类。需要抽出上层统一接口， 然后增加实现类， 对外暴露接口。来源作者：大道方圆 Link"
  }
  
]

