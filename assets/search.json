[
  
    
    {
      "title"    : "Golang GMP 模型",
      "summary"  : "前言 在 golang 的并发编程中，gmp 是一个重要的概念，它代表了 goroutine、m（线程）和 p（调度器）。 这个强大的三位一体的并发模型使得 golang 在处理并发任务时非常高效和灵活。 通过 gmp 的组合，golang 实现了一种高效的并发模型。 它充分利用了多核处理器的优势，并通过轻量级的 goroutine 实现了高并发的编程模式。 但是gpm到底是怎么工作的呢？今天这篇文章就为您解开gpm的神秘面纱。 调度器由来 单进程系统 早期的计算机都是单进程操作系统，各个进程之间都是顺序执行，也就是进程a执行完了才能执行进程b。 「对于cpu来说，进程和线程是一样的，这里我们就不讨论进程和线程的区别了」 存在的问题 单一执行流程，计算机只能一个任务一个任务的处理 如果进程a阻塞，会带来很多cpu浪费的时间 多进程/线程操作系统 基于以上的问题，于是就出现了多进程/线程操作系统 系统把cpu分成了一段一段的时间片(微妙级别) cpu在第一个时间片执行进程A，然后切换到进程B执行，再切换到进程C，一直这样轮询的执行 因为cpu被分成的时间片是微妙级别的，所以直观的感觉就是进程A，B，C是在同时执行的 多进程/线程操作系统的确解决了阻塞的问题，但是又出现了新的问题 存在的问题 因为cpu需要不断地进程A，B，C之间切换，切换肯定避免不了各种复制，计算等消耗，所以在切换过程中浪费掉了很多时间成本，所以「进程/线程越多」，切换「成本就越大」，也就越「浪费」 在这种模式下运行CPU在切换动作上浪费的时间成本大概是40%，只有60%的时间是在执行程序 进程和线程对内存的占用是比较大的，在32位的操作系统中，进程占用的虚拟内存大概是4GB，现成占用内存大概是4M 协程的诞生 对于一个线程来说其实分为两部分，「用户空间」和「内核空间」。 内核空间主要是指操作系统底层，包括进程开辟，分配物理内存资源，磁盘资源等。 用户空间主要是编码业务逻辑部分 于是有人想到能不能把线程的内核空间和用户空间分开。并且让他们互相绑定在一起 对于cpu来说，只需要关注内核空间的线程就可以了 当然如果只是这样把用户空间的协程和内核空间的线程一一绑定还是没有解决问题的， 如果开启的比较多，那么对应的线程也会跟着一起增加，cpu频繁切换的问题还是没有解决，于是就引入了「调度器」的概念 引入调度器来在各个协程之间切换，cpu只需要关注内核空间的线程即可，这样「解决了cpu在各个协程之间不断切换的问题」 存在的问题 这样设计虽然解决了cpu频繁切换的问题，但是如果协程A发生了阻塞，肯定会导致协程B无法被执行。 而且如果计算机是多核，那么是无法利用到多核的优势的。显然是不合理的。 对于多核的计算机，在内核空间可以开启多个线程（具体开启几个由计算内核决定，人为无法控制）， 所以问题的核心点就转移到了协程调度器上面，不管是什么语言，「协程调度器」做的越好，相对的「cpu利用率」也就越高。 go对协程的处理...",
      "url"      : "http://0.0.0.0:4001/posts/go-gmp",
      "category" : "golang",
      "tags"     : "",
      "keywords" : "",
      "date"     : "2023-12-21 00:00:00 +0000",
      "date_day" : "21",
      "date_my"  : "Dec/2023"
    },
    
  
    
    {
      "title"    : "高内聚低耦合",
      "summary"  : "模块之间存在依赖， 导致改动可能会互相影响， 关系越紧密， 耦合越强， 模块独立性越差。 模块内部的元素，关联性越强， 则内聚越高， 模块单一性更强。 模块 模块就是从逻辑上将系统分解为更细微的部分， 分而治之， 复杂问题拆解为若干简单问题， 逐个解决。 耦合主要描述模块之间的关系， 内聚主要描述模块内部。 模块的粒度可大可小， 可以是函数， 类， 功能块等等。 耦合 模块之间存在依赖， 导致改动可能会互相影响， 关系越紧密， 耦合越强， 模块独立性越差。 比如模块A直接操作了模块B中数据， 则视为强耦合， 若A只是通过数据与模块B交互， 则视为弱耦合。 独立的模块便于扩展， 维护， 写单元测试， 如果模块之间重重依赖， 会极大降低开发效率。 内聚 模块内部的元素， 关联性越强， 则内聚越高， 模块单一性更强。 一个模块应当尽可能独立完成某个功能， 如果有各种场景需要被引入到当前模块， 代码质量将变得非常脆弱， 这种情况建议拆分为多个模块。 低内聚的模块代码， 不管是维护， 扩展还是重构都相当麻烦， 难以下手。 接口设计原则 好的接口应当满足设计模式六大原则， 很多设计模式，...",
      "url"      : "http://0.0.0.0:4001/posts/hight-low-design",
      "category" : "Design",
      "tags"     : "",
      "keywords" : "",
      "date"     : "2017-03-15 00:00:00 +0000",
      "date_day" : "15",
      "date_my"  : "Mar/2017"
    }
    
  
]
